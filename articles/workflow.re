={workflow} 制作ワークフロー

本章では、実際に本を作るときのワークフローを紹介していきます。
TechBoosterがC81からC102まで10年以上をかけて練り上げてきた本を作るよくできた方法を解説します。

必ずこうすべきだというものではなくRe:VIEWを使った同人誌ってこうやってつくったんだよ、という体験記です。
同人誌というジャンルは広く、多様な表現が可能です。
技術誌としての企画、構成、編集、入稿まで制作フローに興味があるとより楽しめると思います。
そしてこれを読んで作ってみたいなと思った方はガイドラインとしてご活用ください。

== よろしい、ならば同人誌だ

同人誌を作りたいと思った時がつくり時です。さぁ作ろう、作りましょう、作るんだ！
書き出す前に、決めておくとスムーズなことがいくつかあります。

 * 参加イベント
 * 執筆内容と構成案

参加イベントの決定は、もっともスケジュールに影響を与えます。なるはやで決めてしまいましょう。
技術書を頒布する@<fn>{hanpu}のにもっとも適したイベントは技術書典@<fn>{me}です。

//footnote[hanpu][同人用語。有償、無償問わず、イベントで同人誌を提供すること]
//footnote[me][筆者かつ主宰者によるポジショントーク。コミックマーケットも盛況ですよ。技術書典も長く愛されるようになっていると実感しています。率直に嬉しいです]

印刷にかかるお金は変動するのでページ数と部数は早めに想像しておきましょう。
この段階では、きっちり固まっている必要はありません@<fn>{eng}。
執筆を始める前に、ざっくりと頭の中に書く内容を固めておきましょう。
具体的にはドキュメントセクションのレベル2ぐらい、つまり章と節のタイトル、それぞれの内容を最大3行程度で表現したリード文があれば安心です。

//footnote[eng][もしあなたがエンジニアなら見積もりの困難さはご存知ですね]

== GitHub Oriented Writing

TechBoosterがどういう順番で執筆を行っているのか解説します。
1人だったり、2〜3人でやってたりするサークルだと少し大げさかもしれませんが参考になるでしょう。

技術書を書いてみたいという気持ちになったら友達を誘って共同で執筆を進めてみてください。
きっと締め切り前でも楽しいはずです。兼任でいいので編集役が決まっているとスムーズでしょう。

プログラマであれば周知のとおり、一箇所にすべての情報が集まっているのが一番効率がよく、情報のありかがわからなくて困る事態にも陥りにくいです。

そのためネタ出しから目次の作成、執筆、レビューと手直し、編集までGitHub上で行っています（@<img>{workflow}）。

//image[workflow][よく分かる図解][scale=0.50]{
digraph G {
  planning [label="企画"];
  meeting [label="ネタ出し会議"];
  make_repo [label="GitHubにリポジトリ作成"];
  make_index [label="目次案作成"];
  writing [label="バリバリ執筆 & 修正"];
  pr_review [label="レビューをpull requestで送る"];
  merge [label="レビューのmerge"];
  freeze [label="執筆終了"];
  editing [label="編集作業"];
  submit [label="印刷所へ入稿"];

  planning   -> meeting;
  meeting    -> make_repo;
  make_repo  -> make_index;
  make_index -> writing;
  writing    -> pr_review;
  pr_review  -> merge;
  merge      -> writing;
  merge      -> freeze;
  freeze     -> editing;
  editing    -> submit;

  planning [shape=Mdiamond];
  submit [shape=Msquare];
}
//}

大まかな流れは次のとおりです。

 1. 企画会議に先立って1つのIssue/Slackに知りたいネタを書き込む
 2. オフラインで集合し、ネタの分配や争奪戦を行う
 3. 1冊＝1リポジトリでプライベートリポジトリを作成する
 4. 1ネタ＝1Issue＝1章という単位で目次案を書く
 5. ひたすら書く。main branchに直pushでOK
 6. レビューを受ける
 7. レビュー指摘の修正作業を行う
 8. 編集者が校正＆調整作業に入る（直pushの禁止。変更はpull requestを送る）
 9. 印刷所への入稿作業。このフェーズからGitHubは利用されなくなる

いくつか補足します。

==== ひたすら書く。main branchに直pushでOK

これは同一の@<tt>{.re}ファイルを複数人で編集する機会が少ないからです。
Re:VIEWでは章単位のファイル構成となるため、章ごとに著者が異なっておりconflictが発生しないのであればpull requestにする必要性は薄いです。

WIP@<fn>{wip}として、書き終わるまでmain branchにmergeしない方法もあります。
しかし、常にmain branchで（もちろんビルドが通る状態であることは前提ですが）作業をすると、他の人の進捗もわかりやすく、本全体のページ数も掴みやすく、あまり執筆が進んでいない著者に圧力もかけやすくなります。
さらに著者がRe:VIEW記法そのものに不慣れであるケースも多いのですがmain branchにmergeするタイミングでエラーに悩まされることを防げます。締切直前で忙しいときは誰もが忙しいので余裕をうまく使ってください。

//footnote[wip][Work In Progress つまり書きかけ・作りかけの状態のこと]

執筆というのは著者同士による圧力鍋バトルなので頑張りましょう。
早く書いてアガリを迎え、まだできていない人に圧力をかけねば自分が圧力をかけられる側に堕ちる@<fn>{counterattack}のです。

話がそれました。

//footnote[counterattack][負け犬の戦略としてはすでに書き上がっている人間にもう一本書かないの？と圧をかけ返す手法があります（負けます）]

==== レビューを受ける

レビューは執筆の進捗に応じて２回程度行っています。プログラミングでのレビューと同じく複数の観点があります。
慣れないうちは意識して使い分けることをおすすめします。

 : 構造のレビュー
   章の目次や節の順序など執筆者の主張が適切な形で含まれているか、前提や節など構成の不足を確認します
 : 文章のレビュー 
   センテンス単位のレビューです。主語が適切か用語が正確か、読みづらさを感じないように注意深くみていきます

まずは構造が適切かという視点でのレビューです。目次案、またはごく簡単に構成したスケルトン状態のものに対して、対象読者や筆者の視点、技術的に説明したい内容を十分カバーしている章立てかなど確認します。
この状態では主にIssueでのやり取りがメインです。

文章を書き上げた初校の段階で詳細なレビューを行います。
@<chapref>{writing-book}でも少し触れましたが初校レビューはインラインコメントとして@<tt>{.re}ファイル中に書くケースが大半です。

これは、レビュー内容を取り込むときにWebサイトと見比べながら行うのが面倒であること、レビュワー同士で他にどういうコメントがあるかが把握できたほうが学びが多く、指摘の重複も少ないからです。

#@# prh:disable
コメントを書いた後、直接main branchにpushしない理由は筆者の修正とconflictが発生しやすいためです。
筆者は好きなときに好きなものを書き、気が向いたときにレビューの反映作業を行うのが精神衛生上よいでしょう。

文章そのものへの指摘ではない、章の構造などより大きな視点で指摘する場合は、レビューのフェーズを問わずIssueのみを使って、やりとりを進めるケースがあります。

重要な点としてレビュー指摘をどう反映するかは著者の裁量に任せています。
もちろん、この後の行程では編集者が手を加えるのでヒエラルキーはレビュー＜執筆者＜編集者です。

これは執筆の段階では納得のいく指摘のみ取り込んで欲しいからです。レビューをすべて取り込むことがよいことではありません。とくに多くの観点をケアしようとするあまり冗長になるというのは、わたしたちが考える最も大きなデメリットです。
わかりやすい文章がすべてをカバーしていることは稀で、何を書かないかの選択も重要です。
編集も著者の主張が適切に伝わるか、という観点で作業します。

==== 編集者が校正＆調整作業に入る（直pushの禁止。変更はpull requestを送る）

main branchの凍結後にmain branchを変更する権限をもつのは編集者（TechBoosterでは@<kw>{mhidaka,ひつじ}）だけです。
執筆者がどうしても修正したい場合、pull requestを送り、お伺いを立てます。

これは編集や校正フェーズが印刷所への入稿に向け、ページ数の調整を行っている段階だからです。
本ルールを守らない場合、PDF化したときに改行の具合やら1行あたりの文字数やらの細かな調整がご破算になり編集者がぷっぷくぷー！になります。本気で可哀想なのでやめてあげましょう。

== 執筆のための継続的インテグレーション - Docker & GitHub Actions

エンジニアであればmain branchビルドが壊れることを極端に怖がると思います。正しい。
そこでTechBoosterではCIのための仕組みを制作しました。平たくいうと常に最新のPDF出力が得られます。
ここで重要なのは印刷を目的としたレイアウトで確認できるという点です。ソフトウェア開発でも成果物をビルドしてプロジェクトのデリバリを担保していますが、技術書の制作環境でも似ています。

Re:VIEWはPDFだけでなくEPUBやHTMLなど各種フォーマットに対応しているので、執筆中の出力だってドラフトやHTML出力だけでいいんじゃない？と考えることもできますが、印刷が前提だと最終確認するだけで心許なく感じます。締切ギリギリにあがった原稿を編集者だけでチェックして印刷するなんて無茶は誰だってしたくありません。というわけで印刷用であったり最終レイアウトだったりのリリース向けの成果物を執筆中でも確認できるようにします。少なくとも著者がチェックできていないケースはなくなります。

 : Re:VIEW image for Docker
   @<href>{https://hub.docker.com/r/vvakame/review/}
 : Re:VIEW-build-artifact-action
   @<href>{https://github.com/marketplace/actions/review-build-artifact-action}

TechBoosterではDocker上でRe:VIEWを動かすツールおよびGitHub Actionsとして実行するラッパーツールを用意して常に最新のPDF出力が得られるような運用をしています。これには多くのメリットがありますが中でも次のような点で執筆に貢献しています。

 * ビルド環境の準備が不要になる
 * Re:VIEWの文法エラーにすぐ気づける
 * レビュー対象物を特定できる

TechBoosterでは40人程度が執筆に関わるので全員に特定のプラットフォームを強制することはできません。戦争が起きます。CIとVisual Studio Codeのlanguage-reviewがあればローカルで文法チェックを行ってCIがビルドする、という形で最低限の執筆環境ができます。

またmain branchが壊れている場合もすぐに気づけるため、常にクリーンな環境を維持できます。
エンジニアにとってビルドエラーの恐怖は説明するまでもありませんね。

レビュー期間も同様です。著者からのpushを停止させずにレビューしようと思うと、どこかにレビュー用のPDFがあることが望ましいわけです。そこで前述の仕組みが活きます。CIでは入校時と同じスタイルを利用して常に入稿形式に準じたPDFを生成しています。レビューでも紙面レイアウトでチェックすることで文字のはみ出しなど些細な問題でも素早く気づき、筆者にフィードバックを返すことができます。

実際の所、CIサーバの構築は手間がかかるのでTechBoosterでメンテナンスしています。手軽に得られるビルド環境としてDockerイメージRe:VIEW image for Docker@<fn>{docker-image}を提供し、Dockerイメージを流用しやすいGitHub Actionsを作っています。ReVIEW-Templateリポジトリ@<fn>{yattane}をテンプレートとして使うだけで、これらの環境が整います。すごいね！やったね！

//footnote[docker-image][@<href>{https://hub.docker.com/r/vvakame/review/}]
//footnote[yattane][@<href>{https://github.com/TechBooster/ReVIEW-Template}]
